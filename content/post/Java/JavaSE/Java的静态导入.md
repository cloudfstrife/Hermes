---
title: "Java的静态导入"
date: 2019-03-04T15:11:28+08:00
categories:
- Java
tags:
- Java
keywords:
- Java
- 静态导入
---

Java程序不允许定义独立的函数，变量，常量（被final修饰的变量）。即使一些函数，变量，常量不依赖于任何其它的东西，也需要一个类或者接口来封装这些元素。经常使用static修饰符，定义为这个类或接口的静态成员。访问时，通过类名.元素名来访问。如果只是偶尔访问这些东西一下，这样的写法并没有什么问题；但是如果要频繁访问这些元素，这样的写法会比较麻烦。

J2SE 5.0里引入了“静态导入”机制，通过“静态导入”可以将这些元素做在当前类直接可见，使用这些静态成员无需再给出他们的类名。

<!--more-->

## 精确静态导入

精确的导入一个静态成员的方法，是在源文件的开头部分（任何类或接口的定义之前），加上类似这样的声明：

```java
import static 包名.类或接口名.静态成员名;
```

示例：

```java
package org.hibiscus.demo;

public class Demo {

	public static int desc;
	
	public static int fun(int a,int b){
		return a+b;
	}
}
```

代码2

```java
package org.hibiscus.main;

import static org.hibiscus.demo.Demo.*;

public class Main {

	public static void main(String[] args) {
		System.out.println(fun(1, 2));
	}
	
}
```

> 特别注意：
> 
> Java语言并不要求每个类和接口都必须属于某一个包。
> 
> 但是，在J2SE1.4以后，**对于不属于任何包的类和接口，是既不能用import导入它本身，也不能用import static导入它的静态成员的。**


## 按需静态导入

静态导入可以使用*来导入

```java
import static 包名.类或接口名.*;
```

这种方法只有在虚拟机遇到不明的方法调用或者变量时，才会去静态导入的类中查找。并不是把所有类中的静态变量，常量，方法全部导入当前执行的类。

## 静态导入的访问控制

static import不能突破Java语言中原有的访问控制机制的限制，不过也并不在这方面增加新的约束。

原来有权限访问的静态成员，都可以被导入和使用；而原来无权限访问的静态成员，用了这个方法之后也仍然是访问不能。

## 导入的冲突问题

不同包，不同类中，可能存在相同的静态属性或者方法，这时，如果同时静态导入相同的属性或者方法会产生静态导入的冲突。

此时，如果两个属性或者方法都是精准的静态导入或者都使用按需导入时，会造成编译错误，例如下面的错误：

```java
The method fun(int, int) is ambiguous for the type Main
```

如果其中一个是精准的静态导入，另一个是按需导入，那么，精准的静态导入为有效。

有时静态导入的属性或者方法与本地的属性或者方法产生冲突，此时的处理规则为“本地优先”

## 静态导入的缺点

静态导入会在一定程度上降低代码的可读性，在使用不当的时候可能给维护工作带来一定的困扰。
